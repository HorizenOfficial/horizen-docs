# Claiming mainchain ZEN

This section covers the steps to follow to claim old mainchain ZEN balances after the migration.<br/>

## Who needs to execute the manual claim?

Only ZEN balances coming from the old ZEND Mainchain will need to be manually claimed.<br/>
If you only had funds on EON Chain, your balances will be automatically moved to the same address in the new chain, and no manual operation will be needed.

## Why is the manual claim needed?

A simple manual claim of the funds is required because the address format on the two chains is different (Bitcoin-format in the old Horizen chain, Ethereum format in the new Horizen chain). The on-chain UTXO structure does not track the original key/address owning it, making it impossible to automatically map between old and new addresses.

## How to claim

The old mainchain is a Bitcoin-like chain, where funds are locked in multiple cryptographic "boxes" called UTXO.<br/>
To unlock funds, you will need to generate a signature of a specific message with the same private key able to "unlock" the corresponding UTXOs.<br/>
Two additional method are developed to allow a "direct" claim that doesn't need any signed message.<br/>
The claim will then be performed on-chain, by calling a method on the official Horizen migration contract.<br/>
Here the details about the method call:

### Pay-to-pub-key hash Claim

This is the most common format of UTXO, used for example by the Horizen Sphere Wallet and many other non-custodial wallets.<br/>
The Solidity method to claim this kind of UTXOs is the following:

```
    function claimP2PKH(address destAddress, 
                        bytes memory hexSignature, 
                        PubKey calldata pubKey) public 
```

#### Parameters details:

- destAddress:  Destination address on Base of the funds to be claimed. 
  This can be generated by any keypair (using the same previous private-key is not mandatory), and can be different from the tx caller.<br/>
- hexSignature:  ECDSA/Secp256k1 Signature generated with the private key associated with the UTXOs to claim, of the following message:<br/>
  “ZENCLAIM” + destAddress <br/>
  (destAddress here is represented in the hex form according to EIP-55, with “0x” prefix. No space has to be inserted after “ZENCLAIM” string).
- pubKey: public key associated to the same private key used for the signature and owning the UTXOs.
  Must be always sent in uncompressed form: the PubKey data structure is composed of two bytes32 fields, that represents two components x and y (first 32 bytes and second 32 bytes). 


#### Events emitted:

After a successful claim the following event will be emitted:

```
event Claimed(address destAddress, bytes20 zenAddress, uint256 amount)
```

### Pay-to-script-hash Multisig Claim

This kind of UTXO is associated to multi-signature wallets.
Note: we do not support any other type of Pay-to-script-hash different from the Multisig one.

The Solidity method to claim this kind of UTXOs is the following:

```
    function claimP2SH(address destAddress, 
                       bytes[] memory hexSignatures, 
                       bytes memory script, 
                       PubKey[] calldata pubKeys)
```
#### Parameters details:

- destAddress:  Destination address on Base of the funds to be claimed. 
  This can be generated by any keypair (using the same previous private key is not mandatory), and can be different from the tx caller.
- hexSignatures[]:  List of ZEND ECDSA/Secp256k1 Signatures: Generated with the private keys associated to the multisig address, of the following message:<br/>
  “ZENCLAIM”+ zen_multisig_address + destAddress: 
  - zen_multisig_address: hex representation of zen multisig address derived from this script (base58check decoded representation without chain prefix (leading 2 bytes removed, so in total 20 bytes)  prepended with "0x" prefix) 
  - destAddress: destination address represented in the hex form according to EIP-55, with “0x” prefix.
  - No space has to be inserted between the three parts of the string.
  - The minimum amount of valid signatures defined in the multisig script must be satisfied (example: 3 out of 5).
  - The list size has always to be equal to the total number of signatures accepted by the script, and in case a signature is not present the corresponding element should be set to a 0 bytes array.
For example: if the scripts accepts 2 out of 3 signatures, and we have only A and C signatures, the hexSignatures list will be:
[SigA, 0, SigC]
- script: full UTXO redeem script.
- pubKeys: List of public keys accepted by the script. Must be always sent in uncompressed form: the PubKey data structure is composed of two bytes32 fields, that represents two components x and y (first 32 bytes and second 32 bytes).<br/>
  The array length and  position of elements must correspond to those defined in the script and to the array of signatures.<br/>
  If a key signature is not present, also the corresponding pubKeys X and Y must both be *bytes32(0)*

#### Events emitted:

After a successful  claim the following event will be emitted:

```
event Claimed(address destAddress, bytes20 zenAddress, uint256 amount)
```

### Direct Claim - 1st method

This method can be invoked by anyone and it is used to claim any P2PKH UTXO received on a Zend address calculated from the Base address on which you want to claim. Anyone can invoke the method for any Base address that has a corresponding Zend address with a dumped value different from 0.

The Solidity method to execute this claim is the following:

```
    function claimDirect(address baseDestAddress) public 
```

#### Parameters details:

- baseDestAddress: Destination address on Base of the funds to be claimed.<br/>

Any Base address is a valid *baseDestAddress*, and that address could claim the funds for the Zend Address generated as such:

1) Calculate SHA256 hash of the baseDestAddress
2) Calculate Ripemd160 hash of the output from step 1
3) Concatenate prefix: `0x2089` for ZEND Mainnet
4) Encode it in Base 58

The procedure could be resumed by the formula:
`base58.encode(‘0x2089’  + Ripemd160(SHA256(baseDestAddress)))`

And can be calculated using the following Javascript code

```javascript
 const createHash = require('create-hash')
 const bs58check = require('bs58check')
 
 const prefix = '2089'
 const baseDestAddress = //Base address in string form without '0x' prefix
 
 const ZENDTransferAddress = bs58check.encode(
   Buffer.from(
     prefix +
     createHash('rmd160').update(
       createHash('sha256').update(
         Buffer.from(baseDestAddress, 'hex')
       ).digest()
     ).digest('hex'),
   'hex')
 )
 console.log(ZENDTransferAddress)
```

The owner of an arbitrary Zend address should migrate its funds on the Zend address generated in this way before the Zend Backup is extrapolated.

As example, we consider a Zend address owner preparing for the migration that want to use the direct claim:
1) They generate a Base wallet and get its address, for example: `0x6ebacd4a2a48728e98aAAA101C59f2e0c57fA987`
2) They execute the code above with parameter `baseDestAddress = 6ebacd4a2a48728e98aAAA101C59f2e0c57fA987`. The output is `zncwpByDSdYjCw3HipRY8MS5dRRsxSR7AGU`
3) Before the Zend snapshot block is generated, it sends a transaction to move their ZEN from their original address to the generated one (`zncwpByDSdYjCw3HipRY8MS5dRRsxSR7AGU`)
4) After the snapshot is taken, they invoke the method `claimDirect(0x6ebacd4a2a48728e98aAAA101C59f2e0c57fA987)` on the migration Smart Contract. Any address could be the sender of this transaction
5) The ZEN balance will be restored as ZEN ERC-20 token balance on Base chain on the address `0x6ebacd4a2a48728e98aAAA101C59f2e0c57fA987`

#### Events emitted:

After a successful claim the following event will be emitted:

```
event Claimed(address destAddress, bytes20 zenAddress, uint256 amount)
```

### Direct Claim - 2nd method

This method can be invoked by anyone and it is used to claim any P2PKH UTXO received on a 1-of-2 multisig Zend address on which one of the public keys can be calculated from the Base address on which you want to claim. The other public key can be anyone, so it is possible for the user to remain in control of their funds on Zend using an owned key. Anyone can invoke the method for any Base address that has a corresponding multisig Zend address with a dumped value different from 0.

The Solidity method to execute this claim is the following:

```
    function claimDirectMultisig(bytes memory script, address baseDestAddress) public
```

#### Parameters details:

- script: P2SH Script of the 1-of-2 multisig address to claim
- baseDestAddress: Destination address on Base of the funds to be claimed.<br/>

Any Base address is a valid *baseDestAddress*, and that address could claim the funds for the multisig Zend Address generated as such:

1) Calculate SHA256 hash of the baseDestAddress
2) Create a 1-of-2 multisig address using as **second** public key the hash calculated at Step 1 with "02" as prefix

The address can be created using the following Javascript code:

```javascript
 const zencashjs = require('zencashjs')
 const bs58check = require('bs58check')
 const createHash = require('create-hash')
 
 const baseDestAddress = //Base address in string form without '0x' prefix

 const directMultisigPubKey1 = //Insert any owned public key
 const directMultisigPubKey2 = "02"+createHash('sha256').update(Buffer.from(baseDestAddress, 'hex')).digest('hex')

 multisigScript = zencashjs.address.mkMultiSigRedeemScript([directMultisigPubKey1, directMultisigPubKey2], 1, 2);
 const zenDirectMultisigAddress = zencashjs.address.multiSigRSToAddress(multisigScript); 

 console.log(multisigScript)
 console.log(zenDirectMultisigAddress)
```

The owner of an arbitrary Zend address should migrate its funds on the multisig Zend address generated in this way before the Zend Backup is extrapolated, then invoke `claimDirectMultisig` method on claim smart contract with `multisigScript` and `baseDestAddress` as parameters.

#### Events emitted:

After a successful claim the following event will be emitted:

```
event Claimed(address destAddress, bytes20 zenAddress, uint256 amount)